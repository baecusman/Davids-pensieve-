import { supabase } from "../../auth/supabase"
import type { ContentEntity, AnalysisEntity, ConceptEntity, RelationshipEntity } from "../schema"
import { v4 as uuidv4 } from 'uuid';


// Helper function to generate content hash (consider a more robust one for production)
function generateSimpleHash(text: string): string {
  let hash = 0;
  for (let i = 0; i < text.length; i++) {
    const char = text.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash |= 0; // Convert to 32bit integer
  }
  return hash.toString(36);
}

export class ContentRepository {
  private generateContentHash(content: string): string {
    return generateSimpleHash(content)
  }

  async createContent(data: {
    title: string
    url: string
    content: string
    source: string
  }): Promise<string | null> {
    const hash = this.generateContentHash(data.content)
    const existing = await this.findByHash(hash)
    if (existing) {
      console.log("Content already exists:", existing.title)
      return existing.id
    }

    const newId = uuidv4();
    const { data: newContent, error } = await supabase
      .from<ContentEntity>("content")
      .insert([
        {
          id: newId, // Ensure ID is provided if not auto-generated by DB
          title: data.title,
          url: data.url,
          content: data.content,
          source: data.source,
          hash,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        },
      ])
      .select("id") // Select the ID to return
      .single(); // Expect a single row back

    if (error) {
      console.error("Error creating content:", error)
      return null
    }
    return newContent?.id || null;
  }

  async createAnalysis(data: {
    contentId: string
    summary: AnalysisEntity["summary"]
    entities: Array<{ name: string; type: ConceptEntity["type"] }>
    relationships: Array<{
      from: string
      to: string
      type: RelationshipEntity["type"]
    }>
    tags: string[]
    priority: AnalysisEntity["priority"]
    fullContent?: string
    confidence?: number
  }): Promise<string | null> {
    const conceptEntities = await this.upsertConcepts(data.entities)

    const analysisId = uuidv4();
    const newAnalysisData: Omit<AnalysisEntity, 'id' | 'createdAt' | 'updatedAt'> & { id: string; createdAt: string; updatedAt: string, relationships: RelationshipEntity[] } = {
        id: analysisId,
        contentId: data.contentId,
        summary: data.summary,
        entities: conceptEntities, // Assuming this is how Supabase expects it (e.g., JSONB)
        relationships: [], // Will be populated after relationships are created
        tags: data.tags, // Assuming this is how Supabase expects it (e.g., array of text)
        priority: data.priority,
        fullContent: data.fullContent,
        confidence: data.confidence || 0.8,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
    };


    const { data: analysisResult, error: analysisError } = await supabase
      .from<AnalysisEntity>("analysis")
      .insert(newAnalysisData)
      .select("id")
      .single();

    if (analysisError) {
      console.error("Error creating analysis:", analysisError)
      return null
    }

    const createdAnalysisId = analysisResult?.id;
    if (!createdAnalysisId) {
        console.error("Failed to get ID from analysis creation");
        return null;
    }

    const relationships = await this.createRelationships(data.relationships, conceptEntities, data.contentId)

    // Update analysis with relationships
    // This assumes 'relationships' is a field in your 'analysis' table, likely JSONB
    const { error: updateError } = await supabase
      .from<AnalysisEntity>("analysis")
      .update({ relationships: relationships, updatedAt: new Date().toISOString() })
      .eq("id", createdAnalysisId)

    if (updateError) {
      console.error("Error updating analysis with relationships:", updateError)
      // Potentially handle rollback or error state
      return null;
    }

    return createdAnalysisId;
  }

  private async upsertConcepts(
    entities: Array<{ name: string; type: ConceptEntity["type"] }>,
  ): Promise<ConceptEntity[]> {
    const conceptEntities: ConceptEntity[] = []
    for (const entity of entities) {
      const { data: existing, error: findError } = await supabase
        .from<ConceptEntity>("concepts")
        .select("*")
        .eq("name", entity.name)
        .eq("type", entity.type) // Ensure type is also matched for uniqueness
        .single()

      if (findError && findError.code !== 'PGRST116') { // PGRST116: 0 rows
          console.error("Error finding concept:", findError);
          continue; // Skip this entity or handle error
      }

      if (existing) {
        const { data: updated, error: updateError } = await supabase
          .from<ConceptEntity>("concepts")
          .update({ frequency: existing.frequency + 1, updatedAt: new Date().toISOString() })
          .eq("id", existing.id)
          .select()
          .single();
        if (updateError) {
            console.error("Error updating concept frequency:", updateError)
        } else if (updated) {
            conceptEntities.push(updated)
        }
      } else {
        const newConceptId = uuidv4();
        const { data: newConcept, error: insertError } = await supabase
          .from<ConceptEntity>("concepts")
          .insert({
            id: newConceptId,
            name: entity.name,
            type: entity.type,
            frequency: 1,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
          })
          .select()
          .single();
        if (insertError) {
            console.error("Error inserting new concept:", insertError)
        } else if (newConcept){
            conceptEntities.push(newConcept)
        }
      }
    }
    return conceptEntities
  }

  private async createRelationships(
    relationships: Array<{ from: string; to: string; type: RelationshipEntity["type"] }>,
    concepts: ConceptEntity[], // These are the upserted concepts with their IDs
    contentId: string,
  ): Promise<RelationshipEntity[]> {
    const relationshipEntities: RelationshipEntity[] = []
    for (const rel of relationships) {
      const fromConcept = concepts.find((c) => c.name === rel.from)
      const toConcept = concepts.find((c) => c.name === rel.to)

      if (fromConcept && toConcept && fromConcept.id && toConcept.id) {
        const newRelationshipId = uuidv4();
        const { data: newRelationship, error } = await supabase
          .from<RelationshipEntity>("relationships")
          .insert({
            id: newRelationshipId,
            fromConceptId: fromConcept.id,
            toConceptId: toConcept.id,
            type: rel.type,
            strength: 0.7, // Default strength
            contentId,
            createdAt: new Date().toISOString(),
            // updatedAt is not typically set on creation for relationships unless needed
          })
          .select()
          .single();
        if (error) {
            console.error("Error inserting relationship:", error)
        } else if (newRelationship) {
            relationshipEntities.push(newRelationship)
        }
      }
    }
    return relationshipEntities
  }

  async findByHash(hash: string): Promise<ContentEntity | null> {
    const { data, error } = await supabase
      .from<ContentEntity>("content")
      .select("*")
      .eq("hash", hash)
      .single() // Assuming hash is unique
    if (error && error.code !== 'PGRST116') { // PGRST116: 0 rows, not an error for find
      console.error("Error fetching content by hash:", error)
      return null
    }
    return data
  }

  async findAll(): Promise<ContentEntity[]> {
    const { data, error } = await supabase.from<ContentEntity>("content").select("*")
    if (error) {
      console.error("Error fetching all content:", error)
      return []
    }
    return data || []
  }

  async findById(id: string): Promise<ContentEntity | null> {
    const { data, error } = await supabase
      .from<ContentEntity>("content")
      .select("*")
      .eq("id", id)
      .single()
    if (error && error.code !== 'PGRST116') {
      console.error("Error fetching content by id:", error)
      return null
    }
    return data
  }

  async findBySource(source: string): Promise<ContentEntity[]> {
    const { data, error } = await supabase
      .from<ContentEntity>("content")
      .select("*")
      .eq("source", source)
    if (error) {
      console.error("Error fetching content by source:", error)
      return []
    }
    return data || []
  }

  async findRecent(limit = 10): Promise<ContentEntity[]> {
    const { data, error } = await supabase
      .from<ContentEntity>("content")
      .select("*")
      .order("createdAt", { ascending: false })
      .limit(limit)
    if (error) {
      console.error("Error fetching recent content:", error)
      return []
    }
    return data || []
  }

  async findByTimeframe(timeframe: "weekly" | "monthly" | "quarterly"): Promise<ContentEntity[]> {
    const now = new Date()
    const cutoffDate = new Date()
    switch (timeframe) {
      case "weekly":
        cutoffDate.setDate(now.getDate() - 7)
        break
      case "monthly":
        cutoffDate.setMonth(now.getMonth() - 1)
        break
      case "quarterly":
        cutoffDate.setMonth(now.getMonth() - 3)
        break
    }
    const { data, error } = await supabase
      .from<ContentEntity>("content")
      .select("*")
      .gte("createdAt", cutoffDate.toISOString())
      .order("createdAt", { ascending: false })
    if (error) {
      console.error("Error fetching content by timeframe:", error)
      return []
    }
    return data || []
  }

  async searchContent(query: string): Promise<ContentEntity[]> {
    const { data, error } = await supabase
      .from<ContentEntity>("content")
      .select("*")
      .or(`title.ilike.%${query}%,content.ilike.%${query}%,url.ilike.%${query}%`) // Adjust for full-text search if configured
    if (error) {
      console.error("Error searching content:", error)
      return []
    }
    return data || []
  }

  async getContentWithAnalysis(contentId: string): Promise<{
    content: ContentEntity | null
    analysis: AnalysisEntity | null
  }> {
    const content = await this.findById(contentId)
    const { data: analysis, error } = await supabase
      .from<AnalysisEntity>("analysis")
      .select("*")
      .eq("contentId", contentId)
      .maybeSingle() // Use maybeSingle if analysis might not exist

    if (error) {
      console.error("Error fetching analysis for content:", error)
      return { content, analysis: null }
    }
    return { content, analysis }
  }

  async getAllWithAnalysis(): Promise<Array<{
    content: ContentEntity
    analysis: AnalysisEntity | null // Analysis might not exist for all content
  }>> {
    // This is less efficient. Ideally, use a join or view in Supabase.
    // For simplicity, fetching all content then all analyses and matching them.
    const contents = await this.findAll()
    const { data: analyses, error: analysesError } = await supabase
        .from<AnalysisEntity>("analysis")
        .select("*");

    if (analysesError) {
        console.error("Error fetching all analyses:", analysesError);
        // Return content with null analyses or handle error appropriately
        return contents.map(content => ({ content, analysis: null }));
    }

    const analysesMap = new Map<string, AnalysisEntity>();
    analyses?.forEach(analysis => analysesMap.set(analysis.contentId, analysis));

    const results = contents.map(content => ({
        content,
        analysis: analysesMap.get(content.id) || null
    }));

    return results.sort((a, b) =>
        new Date(b.content.createdAt).getTime() - new Date(a.content.createdAt).getTime()
    );
  }

  async deleteContent(id: string): Promise<boolean> {
    // Consider using Supabase transactions or edge functions for atomicity
    // Delete related analyses
    const { error: analysisError } = await supabase
      .from<AnalysisEntity>("analysis")
      .delete()
      .eq("contentId", id)
    if (analysisError) {
      console.error("Error deleting related analyses:", analysisError)
      return false
    }

    // Delete related relationships (can be complex if not directly linked to contentId)
    // This assumes relationships are linked via contentId. If linked via analysisId or conceptId, adjust.
    const { error: relError } = await supabase
      .from<RelationshipEntity>("relationships")
      .delete()
      .eq("contentId", id) // Assuming RelationshipEntity has contentId
    if (relError) {
      console.error("Error deleting related relationships:", relError)
      // Not returning false here as content might still be deletable
    }

    // Delete content
    const { error: contentError } = await supabase
      .from<ContentEntity>("content")
      .delete()
      .eq("id", id)
    if (contentError) {
      console.error("Error deleting content:", contentError)
      return false
    }
    return true
  }

  async getStats(): Promise<{
    totalContent: number
    bySource: Record<string, number>
    byPriority: Record<string, number> // This might need rethinking if priority is on Analysis
    conceptCount: number
    relationshipCount: number
  }> {
    const { count: totalContent, error: contentError } = await supabase
      .from<ContentEntity>("content")
      .select("id", { count: "exact", head: true });

    // For bySource, more complex or multiple queries might be needed, or a view.
    // Simplified version: fetch all and process locally (less efficient for large datasets)
    const contents = await this.findAll();
    const bySource: Record<string, number> = {};
    contents.forEach(c => bySource[c.source] = (bySource[c.source] || 0) + 1);

    // byPriority: This was on AnalysisEntity. If needed, fetch analyses.
    // For now, an empty object or a different approach is required.
    const byPriority: Record<string, number> = {};
    const { data: analysesForPriority, error: analysesPrioError } = await supabase
        .from<AnalysisEntity>("analysis")
        .select("priority");
    if (analysesForPriority && !analysesPrioError) {
        analysesForPriority.forEach(a => byPriority[a.priority] = (byPriority[a.priority] || 0) + 1);
    }


    const { count: conceptCount, error: conceptError } = await supabase
      .from<ConceptEntity>("concepts")
      .select("id", { count: "exact", head: true });

    const { count: relationshipCount, error: relError } = await supabase
      .from<RelationshipEntity>("relationships")
      .select("id", { count: "exact", head: true });

    if (contentError || conceptError || relError) {
        console.error("Error fetching stats:", { contentError, conceptError, relError });
    }

    return {
      totalContent: totalContent || 0,
      bySource,
      byPriority, // Revisit this based on where priority is stored
      conceptCount: conceptCount || 0,
      relationshipCount: relationshipCount || 0,
    }
  }
}

export const contentRepository = new ContentRepository()
